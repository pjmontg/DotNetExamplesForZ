<#
//*********************************************************
//
//    Copyright (c) Microsoft. All rights reserved.
//    This code is licensed under the Microsoft Public License.
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//*********************************************************
#>
<#@ template language="C#" debug="true" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>

<#@ output extension=".cs"#><#

CodeGenerationTools code = new CodeGenerationTools(this);
MetadataTools ef = new MetadataTools(this);
MetadataLoader loader = new MetadataLoader(this);
CodeRegion region = new CodeRegion(this);

string inputFile = FindEDMXFileName();
string edmxName= Path.GetFileNameWithoutExtension(inputFile);
EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(inputFile);
string namespaceName = code.VsNamespaceSuggestion();

EntityContainer container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
if (container == null)
{
    return "// No EntityContainer exists in the model, so no code was generated";
}
#>
// -------------------------------------------------------------
// <copyright company="Pipeline Group, Inc." file="SyntempoModel.Context.cs">
// COPYRIGHT NOTICE

// SOFTWARE CONTAINING TRADE SECRETS

// Copyright 2012 Pipeline Group, Inc.  (PIPELINE GROUP, INC ). All rights reserved.

// This software and documentation constitute an unpublished work and contain valuable
// trade secrets and proprietary information belonging to the PIPELINE GROUP, INC .
// None of the foregoing material may be copied, duplicated or disclosed without the 
// express written permission of the PIPELINE GROUP, INC .

// PIPELINE GROUP, INC  EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING THIS 
// SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF MERCHANTABILITY AND/OR FITNESS
// FOR ANY PARTICULAR PURPOSE, AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT MIGHT 
// OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF TRADE.
// NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT TO THE USE OF THE SOFTWARE OR 
// DOCUMENTATION. 

// Under no circumstances shall PIPELINE GROUP, INC  be liable for incidental, special, indirect, direct 
// or consequential damages or loss of profits, interruption of business, or related expenses 
// which may arise from use of software or documentation, including but not limited to those 
// resulting from defects in software and/or documentation, or loss or inaccuracy of data 
// of any kind.

// </copyright>
// <author>$Author$</author>
// <remarks>
//   $HeadURL$
//   $LastChangedRevision$ 
//   $LastChangedDate$ 
//   $LastChangedBy$ 
// </remarks>  
// <summary>  
//   Entity Framework context for Oracle database  
// </summary> 
// ------------------------------------------------------------- 

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Data.Objects;
using System.Data.EntityClient;
using Plugin_WorkAssignment.ModelAPI;
using System.Configuration;
using System.Reflection;
using System.Web.Configuration;
using ServicesAPI.Configuration;

<#
if (!String.IsNullOrEmpty(namespaceName))
{
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#
    PushIndent(CodeRegion.GetIndent(1));
}
#>
/// <summary>
/// Context to interface with database
/// </summary>
<#=Accessibility.ForType(container)#> partial class <#=code.Escape(container)#> : ObjectContext
{
	/// <summary>
	/// Connection string to database
	/// </summary>
    public const string ConnectionString = "name=<#=container.Name#>";

	/// <summary>
	/// Name of container
	/// </summary>
    public const string ContainerName = "<#=container.Name#>";

    #region Constructors
	/// <summary>
	/// Static block that one time (thread safe) adds connection string for this edmx
	/// </summary>
    static <#=code.Escape(container)#>()
    {
        // Manipulate connection string to add plugins edmx connection
        typeof(ConfigurationElementCollection).GetField("bReadOnly", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(WebConfigurationManager.ConnectionStrings, false);
            
        // Get configuration
        SyntempoConfiguration config = SyntempoConfiguration.GetConfig();
        ConnectionConfigurationElement connConfig = config.Connection;

        // SQL Server is empty for provider
        string provider = "";
        string providerName = "System.Data.SqlClient";
        switch (connConfig.Type)
        {
            case ConnectionConfigurationElement.ConnectionType.ORACLE:
                provider = "provider = Oracle.DataAccess.Client";
                providerName = "System.Data.EntityClient";
                break;
        }
        ConnectionStringSettings connSettings = new ConnectionStringSettings()
        {
            Name = "<#=code.Escape(container)#>",
            ConnectionString = "metadata=~/bin/WorkAssign/<#= edmxName #>.csdl|~/bin/WorkAssign/<#= edmxName #>.ssdl|~/bin/WorkAssign/<#= edmxName #>.msl;" +
                provider + ";provider connection string=\"DATA SOURCE=" +
                connConfig.Datasource +
                ";PASSWORD=" +
                connConfig.Password +
                ";USER ID=" +
                connConfig.Username + "\"",
            ProviderName = providerName
        };
        WebConfigurationManager.ConnectionStrings.Add(connSettings);
    }

	/// <summary>
	/// Constructor
	/// </summary>
    public <#=code.Escape(container)#>()
        : base(ConnectionString, ContainerName)
    {
<#
        WriteLazyLoadingEnabled(container);
#>
    }

	/// <summary>
	/// Constructor
	/// </summary>
    public <#=code.Escape(container)#>(string connectionString)
        : base(connectionString, ContainerName)
    {
<#
        WriteLazyLoadingEnabled(container);
#>
    }

	/// <summary>
	/// Constructor
	/// </summary>
    public <#=code.Escape(container)#>(EntityConnection connection)
        : base(connection, ContainerName)
    {
<#
        WriteLazyLoadingEnabled(container);
#>
    }

    #endregion

<#
        region.Begin("ObjectSet Properties", 2);

        foreach (EntitySet entitySet in container.BaseEntitySets.OfType<EntitySet>())
        {
#>

	/// <summary>
	/// Retrieve <#=code.Escape(entitySet.ElementType)#> Property
	/// </summary>
    <#=Accessibility.ForReadOnlyProperty(entitySet)#> ObjectSet<<#=code.Escape(entitySet.ElementType)#>> <#=code.Escape(entitySet)#>
    {
        get { return <#=code.FieldName(entitySet) #>  ?? (<#=code.FieldName(entitySet)#> = CreateObjectSet<<#=code.Escape(entitySet.ElementType)#>>("<#=entitySet.Name#>")); }
    }
    private ObjectSet<<#=code.Escape(entitySet.ElementType)#>> <#=code.FieldName(entitySet)#>;
<#
        }

        region.End();

        region.Begin("Function Imports");

        foreach (EdmFunction edmFunction in container.FunctionImports)
        {
            var parameters = FunctionImportParameter.Create(edmFunction.Parameters, code, ef);
            string paramList = String.Join(", ", parameters.Select(p => p.FunctionParameterType + " " + p.FunctionParameterName).ToArray());
            if (edmFunction.ReturnParameter == null)
            {
                continue;
            }
            string returnTypeElement = code.Escape(ef.GetElementType(edmFunction.ReturnParameter.TypeUsage));

#>
    <#=Accessibility.ForMethod(edmFunction)#> ObjectResult<<#=returnTypeElement#>> <#=code.Escape(edmFunction)#>(<#=paramList#>)
    {
<#
            foreach (var parameter in parameters)
            {
                if (!parameter.NeedsLocalVariable)
                {
                    continue;
                }
#>

        ObjectParameter <#=parameter.LocalVariableName#>;

        if (<#=parameter.IsNullableOfT ? parameter.FunctionParameterName + ".HasValue" : parameter.FunctionParameterName + " != null"#>)
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", <#=parameter.FunctionParameterName#>);
        }
        else
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", typeof(<#=parameter.RawClrTypeName#>));
        }
<#
            }
#>
        return base.ExecuteFunction<<#=returnTypeElement#>>("<#=edmFunction.Name#>"<#=code.StringBefore(", ", String.Join(", ", parameters.Select(p => p.ExecuteParameterName).ToArray()))#>);
    }
<#
        }

        region.End();

#>
}
<#
if (!String.IsNullOrEmpty(namespaceName))
{
    PopIndent();
#>
}
<#
}
#>
<#+
  

string GetCurrentDirectory()
{
	string executingDirectoryName = "";
	string stackTraceFileName = new StackTrace(true).GetFrame(0).GetFileName();
	if (String.IsNullOrEmpty(stackTraceFileName))
	{
		throw new ArgumentException("No value was specified for the 'directoryName' configuration parameter" +
			", and we could not figure out the file name from the stack trace (most likely because of running " +
			"the template with debug='False' specified in the <\u0023@ template \u0023> directive.");
	}
	else
	{		
		executingDirectoryName = Path.GetDirectoryName(stackTraceFileName);
	}	
	return executingDirectoryName;
}

string FindEDMXFileName()
{
	string edmxFile = "";
				
	string[] entityFrameworkFiles = Directory.GetFiles(GetCurrentDirectory(), "*.edmx");
	if(entityFrameworkFiles.Length > 0)
		edmxFile = entityFrameworkFiles[0];
	
	return edmxFile;
}

private void WriteLazyLoadingEnabled(EntityContainer container)
{
   string lazyLoadingAttributeValue = null;
   string lazyLoadingAttributeName = MetadataConstants.EDM_ANNOTATION_09_02 + ":LazyLoadingEnabled";
   if(MetadataTools.TryGetStringMetadataPropertySetting(container, lazyLoadingAttributeName, out lazyLoadingAttributeValue))
   {
       bool isLazyLoading = false;
       if(bool.TryParse(lazyLoadingAttributeValue, out isLazyLoading))
       {
#>
        this.ContextOptions.LazyLoadingEnabled = <#=isLazyLoading.ToString().ToLowerInvariant()#>;
<#+
       }
   }
}
#>